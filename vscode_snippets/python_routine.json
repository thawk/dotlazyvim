{
    "mapreduce": {
        "prefix": "mapreduce",
        "body": [
            "import functools",
            "import itertools",
            "import multiprocessing",
            "",
            "",
            "def map_reduce(mapper, reducer, inputs, process_count='auto'):",
            "\t\"\"\"把inputs通过mapper和reducer处理为结果",
            "",
            "\tArgs:",
            "\t\tmapper (Function): 单参数的函数，依次对inputs进行处理",
            "\t\treducer (Function): 接受两个参数，返回一个结果",
            "\t\tinputs (Sequence): 要处理的数据列表",
            "\t\tprocess_count: 数字表示指定了进程数，''或'auto'使用CPU核数",
            "",
            "\tReturns: 最终的结果",
            "",
            "\t\"\"\"",
            "\t# 确定进程数",
            "\tif process_count == '' or process_count == 'auto':",
            "\t\t# 如果只有一个核就直接用当前进程即可",
            "\t\tif multiprocessing.cpu_count() > 1:",
            "\t\t\tprocess_count = multiprocessing.cpu_count()",
            "\t\telse:",
            "\t\t\tprocess_count = 0",
            "\telse:",
            "\t\tprocess_count = int(process_count)",
            "",
            "\tif process_count > 1:",
            "\t\ttry:",
            "\t\t\tinput_count = len(inputs)",
            "\t\t\tif process_count > input_count:",
            "\t\t\t\tprocess_count = input_count",
            "\t\texcept TypeError:  # Can't get len",
            "\t\t\tpass",
            "",
            "\t\tpool = multiprocessing.Pool(process_count)",
            "",
            "\t\tresult = functools.reduce(",
            "\t\t\treducer, pool.imap(mapper, inputs))",
            "",
            "\t\tpool.close()",
            "\t\tpool.join()",
            "\telse:",
            "\t\tresult = functools.reduce(",
            "\t\t\treducer,",
            "\t\t\titertools.imap(mapper, inputs))",
            "",
            "\treturn result"
        ],
        "description": "Sync and Async map/reduce"
    },
    "ip_in_network": {
        "prefix": "ip_in_network",
        "body": [
            "import socket",
            "import struct",
            "",
            "def ip_in_network(ip, net):",
            "\t\"\"\"Is an address in a network",
            "\tArgs:",
            "\t\tip: socket.inet_aton格式或x.x.x.x格式的字符串",
            "\t\tnet: 192.168.0.0/24格式的字符串",
            "\t",
            "\tReturns (Bool): ip是否在net中",
            "\t\"\"\"",
            "\tif len(ip) > 4:",
            "\t\tip = socket.inet_aton(ip)",
            "",
            "\tipaddr = struct.unpack('L', ip)[0]",
            "\tnetaddr, bits = net.split('/')",
            "\tnetmask = struct.unpack('L',socket.inet_aton(netaddr))[0] & ((2L<<int(bits)-1) - 1)",
            "\treturn ipaddr & netmask == netmask"
        ],
        "description": "Check if an ip is in network"
    },
    "add_thousands_sep": {
        "prefix": "add_thousands_sep",
        "body": [
            "def add_thousands_sep(num):",
            "    \"\"\"把数字转换为带千位分隔符的字符串",
            "",
            "    Args:",
            "        num: 要转换的数字。如果是小数，则只为整数部分加上千位分隔符",
            "",
            "    Returns:",
            "        字符串，转换结果",
            "    \"\"\"",
            "    parts = str(num).split('.')",
            "    s = parts[0][::-1] # 反转",
            "    parts[0] = \",\".join([s[i:i+3] for i in range(0,len(s),3)])   # 每三个数字加一个逗号",
            "    parts[0] = parts[0][::-1] # 再反转为正常顺序",
            "",
            "    return \".\".join(parts)"
        ],
        "description": "Add thousands sep"
    },
    "matplotlib_init": {
        "prefix": "matplotlib_init",
        "body": [
            "import matplotlib",
            "matplotlib.use('Agg')",
            "import matplotlib.pyplot as plt",
            "import matplotlib.dates as mdates",
            "from mpl_toolkits.axes_grid1 import make_axes_locatable",
            "",
            "try:",
            "\timport pandas.plotting",
            "\t# Required by recent versions of Pandas, but not old versions",
            "\tpandas.plotting.register_matplotlib_converters()",
            "except:",
            "\tpass",
            "",
            "matplotlib.style.use('ggplot')",
            "",
            "plt.rcParams['agg.path.chunksize'] = 20000",
            "plt.rcParams['font.family'] = 'sans-serif'",
            "plt.rcParams['font.sans-serif'] = ['Microsoft YaHei', 'SimHei'] + matplotlib.rcParams['font.sans-serif']",
            "plt.rcParams['axes.unicode_minus'] = False",
            "",
            "# 属性",
            "fig_size = (12, 8)",
            "fig_dpi = 100",
            "",
            "try:",
            "\tfig_colors = [p['color'] for p in list(plt.rcParams['axes.prop_cycle'])]",
            "except:",
            "\tfig_colors = list(plt.rcParams['axes.color_cycle'])",
            "",
            "fig_marker_styles = list(\".+^*xdsp\")",
            "fig_line_styles = ['-', '--', ':', '-.']"
        ],
        "description": "Init matplotlib"
    },
    "matplotlib_fig": {
        "prefix": "matplotlib_fig",
        "body": [
            "\tfig, ax = plt.subplots(1, 1, width=width, height=height, dpi=dpi)"
        ],
        "description": "Create new figure"
    }
}